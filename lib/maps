Map = struct {
    __init__ = func() {
        self.keys = []
        self.values = []
    } 

    addEntry = func(k, v) {
        self.keys = self.keys + [k]
        self.values = self.values + [v]
    }

    getValueFor = func(key) {
        getKeyIter = func(iter) {
            if (len(self.keys) == iter) {
                nil
            } else if (self.keys[iter] == key) {
                iter
            } else {
                recurse(iter + 1)
            }
        }

        iterOfValue = getKeyIter(0)

        if (iterOfValue == nil) {
            panic("Map", "Cannot find a value attached to this key '" + key + "'")
        } else {
            self.values[iterOfValue]
        }
    }

    getKeyFor = func(value) {
        getValueIter = func(iter) {
            if (len(self.values) == iter) {
                nil
            } else if (self.values[iter] == value) {
                iter
            } else {
                recurse(iter + 1)
            }
        }

        iterOfValue = getValueIter(0)

        if (iterOfValue == nil) {
            panic("Map", "Cannot find key for value '" + value + "'")
        } else {
            self.keys[iterOfValue]
        }
    }

    printAll = func() {
        loop = func(iter) {
            if (iter < len(self.keys)) {
                print(self.keys[iter])
                print(" : ")
                println(self.values[iter])
                recurse(iter + 1)
            }
        }
        loop(0)
    }

    len = func() len(self.keys)

    stringify = func() {
        retVal = "{"

        for iter, key in self.keys do
            val = self.values[iter]

            retVal = retVal + str(key) + ":" + str(val)

            retVal = retVal +
                if self.len() <= iter-1 {
                    ", "
                } else {
                    "}"
                }
        end

        retVal
    }
}

Typed_Map = struct {
    __init__ = func(key_type, value_type) {
        check_type(_type, key_type)
        check_type(_type, value_type)

        self.key_type = key_type
        self.value_type = value_type

        self.keys = []
        self.values = []
    } 

    addEntry = func(k, v) {
        check_type(self.key_type, k)
        check_type(self.value_type, v)

        self.keys = self.keys + [k]
        self.values = self.values + [v]
    }

    getValueFor = func(key) {
        check(self.key_type, key)

        getKeyIter = func(iter) {
            if (len(self.keys) == iter) {
                nil
            } else if (self.keys[iter] == key) {
                iter
            } else {
                recurse(iter + 1)
            }
        }

        iterOfValue = getKeyIter(0)

        if (iterOfValue == nil) {
            panic("Map", "Cannot find a value attached to this key '" + key + "'")
        } else {
            self.values[iterOfValue]
        }
    }

    getKeyFor = func(value) {
        check_type(self.value_type, value)

        getValueIter = func(iter) {
            if (len(self.values) == iter) {
                nil
            } else if (self.values[iter] == value) {
                iter
            } else {
                recurse(iter + 1)
            }
        }

        iterOfValue = getValueIter(0)

        if (iterOfValue == nil) {
            panic("Map", "Cannot find key for value '" + value + "'")
        } else {
            self.keys[iterOfValue]
        }
    }

    printAll = func() {
        loop = func(iter) {
            if (iter < len(self.keys)) {
                print(self.keys[iter])
                print(" : ")
                println(self.values[iter])
                recurse(iter + 1)
            }
        }
        loop(0)
    }

    len = func() len(self.keys)

    stringify = func() {
        retVal = "{"

        for iter, key in self.keys do
            val = self.values[iter]

            retVal = retVal + str(key) + ":" + str(val)

            retVal = retVal +
                if self.len() <= iter-1 {
                    ", "
                } else {
                    "}"
                }
        end

        retVal
    }
}